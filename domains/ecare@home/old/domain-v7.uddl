;; Created from:
;;
;; eating(John,t) :- fridgeDoor(_, Open, T1),
;; 									 fridgeDoor(_, Closed, T2),
;; 									 kitchenSeat(John, Pressed, t),
;; 									 T 1 < T 2 < t.
;;
;; -> Moved door state into fridgeDoor predicate to make clear it's the
;;		same sensor
;;
;; Problem: Configurations as complex terms lead to huge number of operators
;; 					-> Would like to export configuration selection
;;					-> How do robots fit into the picture?
;;							-> They need their own operators and special configuration (location, direction)
;;					-> How about sensors mounted on robots?
;;							-> Moving robot moves all sensors on robot -or- robot is one multi-purpose sensor
;;					-> More information about concepts could be required
;;							-> E.g.: Robot needs to be in kitchen and to look at kitchenSeat to infer kitchenSeatState
;;							-> kitchenSeatState is linked to kitchen and kitchenSeat

(:initial-context
	(:domain
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Inhabitants
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		(enum human { John })
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Environment
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		(enum location { kitchen bedroom livingroom bathroom })
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Sensors
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		
		(enum sensorID { fridgeDoorSensor kitchenSeatSensor })

		(enum nodeID { node1 node2 })
		(enum nodeClass { nodeClass1 })
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Concepts
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		(enum concept { eating fridgeDoorState kitchenSeatState })
		(enum state {on off})
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Devices
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		(enum device {sensorID nodeID})
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; Device Configurations
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		(enum frequency { f1Hz f10Hz f20Hz f30Hz })
		(enum nbits { n1bit n8bit n10bit })
		(enum configuration { default (sensorConfig frequency nbits) robotConfiguration })

		(enum filter { fNone fMovingAverage })
		(enum looking-at { default human })
		(enum robotConfiguration { (robotConfig location looking-at viewing state state) })
		
		(int ms [0 20000])
		(int energy [0 200000])
		(int costID [0 10000])
		(sig (inferring concept))
		(sig (deviceEnergyConsumption device energy))
		(sig (device-state device) state)
		(sig (device-configuration device) configuration)
		(sig (switchOnTime device ms ms))
		(sig (switchOffTime device ms ms))
		(sig (hasNodeClass nodeID nodeClass))
		(sig (capabilityBase nodeClass configuration sensorID configuration concept))
		(sig (capabilityTwo nodeClass configuration concept concept concept))
		(sig (capabilityThree nodeClass configuration concept concept concept concept))
		(sig (allowedTransition device configuration configuration ms ms))
	)
	(:statement
		(s0 (device-state node1) off)
		(s1 (device-state node2) off)
		(s2 (device-state fridgeDoorSensor) off)
		(s3 (device-state kitchenSeatSensor) off)
		(s4 (device-configuration node1) default)
		(s5 (device-configuration node2) default)
		(s6 (device-configuration fridgeDoorSensor)  (sensorConfig f1Hz n1bit))
		(s7 (device-configuration kitchenSeatSensor) (sensorConfig f1Hz n1bit))

	)
	(:goal
		(?G1 (inferring eating))
		(?G2 (inferring kitchenSeatState))
	)
	(:optimization
		(min energy)
	)
	(:temporal
		(at ?G1 [0 10000] [20000 inf])
		(at ?G2 [0 40000] [41000 inf])
	)
	(:include (kb
			<begin-escape-syntax>

hasNodeClass(node1,nodeClass1).
hasNodeClass(node2,nodeClass1).

capabilityBase(nodeClass1, default, fridgeDoorSensor, sensorConfig(f10Hz,n8bit), fridgeDoorState).

capabilityBase(nodeClass1, default, kitchenSeatSensor, sensorConfig(f10Hz,n8bit),  kitchenSeatState).

capabilityTwo(nodeClass1, default, fridgeDoorState, kitchenSeatState, eating).

switchOnTime(node1, 1000, 3000).
switchOffTime(node1, 1000, 3000).
switchOnTime(node2, 1000, 3000).
switchOffTime(node2, 1000, 3000).
switchOnTime(fridgeDoorSensor, 1000, 3000).
switchOffTime(fridgeDoorSensor, 1000, 3000).
switchOnTime(kitchenSeatSensor, 1000, 3000).
switchOffTime(kitchenSeatSensor, 1000, 3000).

deviceEnergyConsumption(node1,10).
deviceEnergyConsumption(node2,5).
deviceEnergyConsumption(fridgeDoorSensor,2).
deviceEnergyConsumption(kitchenSeatSensor,2).

			<end-escape-syntax>
	))
)

(:operator ;; infer concept from single sensor with specific configuration
	(infer-sensor ?Node - nodeID ?SensorID - sensorID ?C - concept)
	(:preconditions
		(?P1 (device-state ?SensorID) on)
		(?P2 (device-state ?Node) on)
	)
	(:effects
		(?Econfig1 (device-configuration ?SensorID) ?SensorConfig)
		(?Econfig2 (device-configuration ?Node) ?NodeConfig)
		(?E (inferring ?C))
	)
	(:constraints
		(:temporal
			;; link operator to effect:
			(equals ?THIS ?E)
			;; require sensor configuration during inference interval:
			(during ?E ?Econfig1 [1 inf] [1 inf])
			(during ?Econfig1 ?P1 [1 inf] [1 inf])
			;; require node configuration during inference interval:
			(during ?E ?Econfig2 [1 inf] [1 inf])
			(during ?Econfig2 ?P2 [1 inf] [1 inf])
		)
		(:prolog kb
			(hasNodeClass ?Node ?NodeClass)
			;; node of specific class in current configuration can use sensor with current configuration to infer target concept
			(capabilityBase ?NodeClass ?NodeConfig ?SensorID ?SensorConfig ?C)

		)
		(:cost
			(add energy 1)
		)
	)
)

(:operator ;; infer a concept from two other concepts
	(infer-from-2 ?C - concept ?Cbase1 - concept ?Cbase2 - concept)
	(:preconditions
		(?P1 (inferring ?Cbase1))
		(?P2 (inferring ?Cbase2))
		(?P3 (device-state ?Node) on)
	)
	(:effects
		(?Econfig (device-configuration ?Node) ?NodeConfig)
		(?E (inferring ?C))
	)
	(:constraints
		(:temporal
			(equals ?THIS ?E)
			;; requires base concepts to be infered during inference interval:	
			(during ?E ?P1 [1 inf] [1 inf])
			(during ?E ?P2 [1 inf] [1 inf])
			;; requires right configuration for inference interval:
			(during ?E ?Econfig [1 inf] [1 inf])
			(during ?Econfig ?P3 [1 inf] [1 inf])
		)
		(:prolog kb
			(hasNodeClass ?Node ?NodeClass)
			(capabilityTwo ?NodeClass ?NodeConfig ?Cbase1 ?Cbase2 ?C)
		)
		(:cost
			(add energy 1)
		)
	)
)

(:operator ;; infer a concept from three other concepts
	(infer-from-3 ?C - concept ?Cbase1 - concept ?Cbase2 - concept ?Cbase3 - concept)
	(:preconditions
		(?P1 (inferring ?Cbase1))
		(?P2 (inferring ?Cbase2))
		(?P3 (inferring ?Cbase3))
		(?P4 (device-state ?Node) on)
	)
	(:effects
		(?Econfig (device-configuration ?Node) ?NodeConfig)
		(?E (inferring ?C))
	)
	(:constraints
		(:temporal
			;; link operator to effect:
			(equals ?THIS ?E)
			;; requires base concepts to be infered during inference interval:
			(during ?E ?P1 [1 inf] [1 inf])
			(during ?E ?P2 [1 inf] [1 inf])
			(during ?E ?P3 [1 inf] [1 inf])
			;; requires right configuration for inference interval:
			(during ?E ?Econfig [1 inf] [1 inf])
			(during ?Econfig ?P4 [1 inf] [1 inf])
		)
		(:prolog kb
			(hasNodeClass ?Node ?NodeClass)
			;; node of specific class in current configuration can use the three base concepts to infer the target concept:
			(capabilityThree ?NodeClass ?NodeConfig ?Cbase1 ?Cbase2 ?Cbase3 ?C) ;; (cam-config ?targeting ?light ?ir ?fps ?resolution)
		)
		(:cost
			(add energy 1)
		)
	)
)

(:operator ;; turn device on and then off again
	(switch-on-off ?D - device)
	(:preconditions
		(?P (device-state ?D) off)
	)
	(:effects
		(?E1 (device-state ?D) on)
		(?E2 (device-state ?D) off)
	)
	(:constraints
		(:temporal
			(equals ?THIS ?E1)
			(before ?P ?E1 [?TminOn ?TmaxOn])
			(before ?E1 ?E2 [?TminOff ?TmaxOff])
		)
		(:prolog kb
			(deviceEnergyConsumption ?D ?CostPerTimeUnit)
			(switchOnTime ?D ?TminOn ?TmaxOn)
			(switchOffTime ?D ?TminOff ?TmaxOff)
		)
		(:domain
			;; assure that each instance of this operator uses a unique cost ID
			(new-object ?CostID costID)
		)
		(:math 
			;; math solver creates lookup that can be used by other modules e.g. with (get-math-value x)
			;;	- ground eval targets can change 
			;;	- variable targets are substituted once as a resolver and then left alone
			;; 	- (EST ?I) etc. should be usable everywhere
			;;  - add evaluation of nested math as below for convenience
			;; 	- parse operator symbols for convenience
			(eval-int (energyCostTotal ?CostID) (mult (sub (EET ?THIS) (LST ?THIS)) ?CostPerTimeUnit))
		)
		(:cost ;; add calculated cost
			(add energy (energyCostTotal ?CostID))
		)
	)
)
