;; Created from:
;;
;; eating(John,t) :- fridgeDoor(_, Open, T1),
;; 									 fridgeDoor(_, Closed, T2),
;; 									 kitchenSeat(John, Pressed, t),
;; 									 T 1 < T 2 < t.
;;
;; -> Moved door state into fridgeDoor predicate to make clear it's the
;;		same sensor
;;
;; Problem 1: Is fridgeDoor really a sensor? If it is a concept that needs 
;; 						processing of a real sensor another layer of operators could be required.
;; 						E.g.: turn on sensor, stream values to node inferring "fridgeDoorOpen", etc.
;;									processing nodes could be multi-purpose but slower to process and turn on

(:initial-context
	(:domain
		(enum human { John })
		(enum sensorID { fridgeDoorSensor kitchenSeatSensor })
		(enum sensorClass { contactSensor pressureSensor })
		(enum nodeID { node1 node2 })
		(enum nodeClass { nodeClass1 })
		(enum concept { eating fridgeDoorState kitchenSeatState })
		(enum state {on off})
		(enum device {sensorID nodeID})
		(int ms [0 100000])
		(sig (inferring concept))
		(sig (device-state device) state)
		(sig (switchOnTime device ms ms))
		(sig (switchOffTime device ms ms))
		(sig (hasNodeClass nodeID nodeClass))
		(sig (capability nodeClass sensorID concept))
	)
	(:statement
		(s0 (device-state node1) off)
		(s1 (device-state node2) off)
		(s2 (device-state fridgeDoorSensor) off)
		(s3 (device-state kitchenSeatSensor) off)
	)
	(:goal
		(?G (inferring eating John))
	)
	(:temporal
		(at ?G [10000 10000] [20000 20000])
	)
	(:include (kb
			<begin-escape-syntax>

		hasNodeClass(node1,nodeClass1).
		hasNodeClass(node2,nodeClass1).
		capability(nodeClass1, fridgeDoorSensor, fridgeDoorState).
		capability(nodeClass1, kitchenSeatSensor, kitchenSeatState).
		sensorClass(fridgeDoorSensor, contactSensor).
		sensorClass(kitchenSeatSensor, pressureSensor).
		switchOnTime(node1, 1000, 3000).
		switchOffTime(node1, 1000, 3000).
		switchOnTime(node2, 1000, 3000).
		switchOffTime(node2, 1000, 3000).
		switchOnTime(fridgeDoorSensor, 1000, 3000).
		switchOffTime(fridgeDoorSensor, 1000, 3000).
		switchOnTime(kitchenSeatSensor, 1000, 3000).
		switchOffTime(kitchenSeatSensor, 1000, 3000).

			<end-escape-syntax>
	))
)

;; TODO/Issues
;;
;; Generalize this for any two source concept
;;	-> could allow compiling all req. knowledge to Prolog
;; How to get better timelines? ET solution will turn on devices too long: 
;;	-> Need to minimize on times of devices
;;	-> Device energy consumption may vary
;; Different plans may be preferable (e.g., switching on again later is bettern than keeping device on the entire day)
;;	-> Keep searching for improvement after first solution
;; Define total cost of a plan 
;;	-> (sum (on-time * energy cost) for all device on times + switch on cost + switch off cost)
;;	-> makespan not interesting (:goals are fixed intervals)
;; What about redundancies? 
;;	-> We may need to activate multiple ways to infer concept to be more confident that it works
;; What about fixing problems online? 
;;  -> Hard temporal constraints on goals become impossible
;;  -> Old goal no longer reachable (it starts in the past)
;; 	-> Need to reach "rest of old goal interval" asap
;; Modeling actuation
;;	-> Robots are movable nodes
;; Modeling reception
;;	-> Could move robot with IPv6 node to fix hole in network due to broken device
;; Random problem generation
;; 	-> Without actuation plans can always be found
;;	-> Fix number of devices, vary number of goals
;;	-> Fix goal complexity (number of concepts goal depends on)
;; Evaluate
;;	-> Types of planners (HTN, CP, PSP)
;;  -> Planning times
;;  -> Costs
;;  -> Optimization VS using first solution
;;  -> Improvement over time during optimization

(:operator ;; creates window during which eating can be inferred with above rule
(infer-eating ?H - human)
	(:preconditions
		(?P1 (inferring fridgeDoorState))
		(?P2 (inferring kitchenSeatState))
	)
	(:effects
		(?E (inferring eating ?H))
	)
	(:constraints
		(:temporal
			(equals ?THIS ?E)
			(during ?E ?P1 [1 inf] [1 inf])
			(during ?E ?P2 [1 inf] [1 inf])
		)
	)
)

(:operator ;; enables inferring simple concept (from single sensor)
	(infer-simple-concept ?Node - nodeID ?SensorID - sensorID ?C - concept)
	(:preconditions
		(?P1 (device-state ?SensorID) on)
		(?P2 (device-state ?Node) on)
	)
	(:effects
		(?E (inferring ?C))
	)
	(:constraints
		(:temporal
			(equals ?THIS ?E)
			(equals ?P1 ?E)
			(equals ?P2 ?E)
		)
		(:prolog kb
			(hasNodeClass ?Node ?NodeClass)
			(capability ?NodeClass ?SensorID ?C)
		)
	)
)

(:operator ;; turn device on and then off again
	(switch-on-off ?D - device)
	(:preconditions
		(?P (device-state ?D) off)
	)
	(:effects
		(?E1 (device-state ?D) on)
		(?E2 (device-state ?D) off)
	)
	(:constraints
		(:temporal
			(equals ?THIS ?E1)
			(before ?P ?E1 [?TminOn ?TmaxOn])
			(before ?E1 ?E2 [?TminOff ?TmaxOff])
		)
		(:prolog kb
			(switchOnTime ?D ?TminOn ?TmaxOn)
			(switchOffTime ?D ?TminOff ?TmaxOff)
		)
	)
)