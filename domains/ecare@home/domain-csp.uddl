(:initial-context
	(:include (kb "./kb.prolog"))

	(:domain
		;; Inhabitants
		(enum human { john })

		;; Environment
		(enum location { kitchen bedroom livingRoom bathroom })
		(enum bed { bedJohn })
		(enum chair {kitchenChair couch	})
		(enum door {fridgeDoor})
		(enum tv {tvJohn})
		(enum shower {showerJohn})
		(enum stove {stoveJohn})
		(enum waterTap {bathroomTabJohn kitchenTabJohn})
		(enum object { bed chair stove tv shower waterTap window door } )
		;; Sensors

		(enum sensorID 
			{ 
				(camera location)
				(camera robot location object)
				;; Mobile sensors
				robot  

				;; Location-based sensors
				(pir location)
				(environmentalSensor location) ;; temperature, humidity
				(luminositySensor location)

				;; Object-based sensors
				(doorSensor door)
				(windowSensor window)
				(pressureSensor chair)
				(pressureSensor bed)

				(waterCurrentSensor shower)
				(waterCurrentSensor waterTap)

				(electricCurrentSensor tv)
				(electricCurrentSensor stove)

				;; Wearable sensors
				(activityTracker human)
			}
		)
		(enum inferenceRequirement { none atLocation facingHumanAtLocation })
		(enum nodeClass { lowPowerProcessor generalPurposeProcessor })
		;;;;;;;;;;;;;;;;;;;
		;; Concepts
		;;;;;;;;;;;;;;;;;;;
		(enum concept 
			{ 
				(activity human)
				(activityLevel human)  

				(eating human)
				(showering human)
				(sleeping human)
				(cooking human)

				(doorState door) 
				(windowState window) 
				(chairState chair) 
				(bedState bed) 

				(temperature location)
				(humidity location)
				(airQuality location)
				(luminosity location)

				(humanPressence location)

				(using waterTap)
				(using shower)
				(using tv)
				(using stove)
			}
		)
		(enum state {on off})
		;;;;;;;;;;;;;;;;;;;
		;; Devices
		;;;;;;;;;;;;;;;;;;;
		(enum device {sensorID})
		(enum agent {human device none})
		(enum entity {none device human robot bed chair stove tv shower waterTap window door object})

		(enum timePoints {past future})
		
		(int ms [0 20000])
		(int energy [0 200000])
		(int costID [0 10000])
		(int usage [0 10])

		(sig time timePoints)
		(sig (at entity) location)
		(sig (facing device) entity)
		(sig (adjacent location location))
		(sig (facingEntityAtLocation human))
		(sig (isMobile device))
		(sig (canRotate device))
		(sig (inferring concept))
		(sig (deviceEnergyConsumption device energy))
		(sig (device-state device) state)
		(sig (hasNodeClass nodeClass))
		(sig (capabilityBase sensorID inferenceRequirement concept))
		(sig (capabilityTwo concept concept concept))
		(sig (capabilityThree concept concept concept concept))
	)
	(:statement
		(past (time) past)
		(future (time) future)

		(s1 (at john) kitchen)
		(s2 (at robot) kitchen)
		(s3 (facing robot) none)

		(s4 (at (camera bedroom)) bedroom)
		(s5 (at (camera livingRoom)) livingRoom)
		(s6 (at (camera kitchen)) kitchen)

		(s7 (at bedJohn) bedroom)
		(s8 (at kitchenChair) kitchen)
		(s9 (at fridgeDoor) kitchen)
		(s10 (at tvJohn) livingRoom)
		(s11 (at showerJohn) bathroom)
		(s12 (at stoveJohn) kitchen)
		(s13 (at bathroomTabJohn) bathroom)
		(s14 (at kitchenTabJohn) kitchen)
		(s15 (at couch) livingRoom)
	)

	(:configuration-planning
		;; This is a request from WP2 (including temporal constraint on interval ?I)
		(goal I1 (eating john))

		;; These should be added from ontology
		(link (eating john) (list (eating john kitchen) (eating john livingRoom) ))
		(link (eating john kitchen) {(doorState fridgeDoor) (chairState kitchenChair)})
		(link (eating john kitchen) {(camera robot kitchen table)})
		(link (eating john livingRoom) {(doorState fridgeDoor) (chairState couch)})
		(link (eating john livingRoom) {(camera robot livingRoom couch)})
		(link (doorState fridgeDoor) {(doorSensor fridgeDoor)})
		(link (chairState kitchenChair) {(pressureSensor kitchenChair)})
		(link (chairState couch) {(pressureSensor couch)})								
		(link (camera robot kitchen table) {})
		(link (camera robot livingRoom couch) {})
		(link (doorSensor fridgeDoor) {})
		(link (pressureSensor kitchenChair) {})
		(link (pressureSensor couch) {})

		;; This should/could be looked up from Prolog/ontology
		(cost (doorSensor fridgeDoor) 1)
		(cost (pressureSensor kitchenChair) 1)
		(cost (pressureSensor couch) 1)
		(cost (camera robot kitchen table) 100)
		(cost (camera robot livingRoom couch) 100)

		;; This should be added by monitoring system (ICs adding or deleting these)
		(unavailable (pressureSensor couch))
	)

	(:input ssn "ssn.owl")

	(:ic
		(read-from-ontology ...)
		(:condition 
			(:owl ssn
				(link ?C ?List)
			)
		)
		(:resolver 
			(:configuration-planning
				(link ?C ?List)
			)
		)
	)

	(:ic
		(robot-camera-goal ?R ?L ?O ?I)
		(:condition (:statement (?I (inferring (camera ?R ?L ?O))) ) )
		(:resolver (:goal (?G1 (at ?R) ?L) (?G2 (facing ?R) ?O) ) )
	)

	(:temporal
		(planning-interval [0 inf])
	)

	(:optimization
		(min energy)
	)

	(:ic
		(attach-costs ?Device ?I)
		(:condition
			(:statement
				(?I (device-state ?Device) on)
			)
			(:prolog kb 
				(deviceEnergyConsumption ?Device ?CostPerTimeUnit)
			)
		)
		(:resolver
			(:domain
				;; assure that each instance of this operator uses a unique cost ID
				(new-object ?CostID costID)
			)
			(:math 
				(eval-int (energyCostTotal ?CostID) (mult (sub (EET ?I) (LST ?I)) ?CostPerTimeUnit))
			)
			(:cost
				(add energy (energyCostTotal ?CostID))
			)
		)
	)
)

(:operator 
	(move-device ?Device - device ?L1 - location ?L2 - location)
	(:preconditions
		(?P1 (at ?Device) ?L1)
	)
	(:effects
		(?E1 (at ?Device) ?L2)

		;; How to make this type of effects available during planning:
		;(forall ?X ; moving a device moves all devices mounted on/carried by that device
		;	(such-that 
		;		(:statement (?EX (on ?X) ?Device))
		;		(:temporal (overlaps ?P1 ?EX [1 inf]))
		;	)
		;	(add 
		;		(:statement (?EXeff (at ?X) ?L2))
		;		(:temporal (distance (ST ?EXeff) (ST ?E) [0 0]))
		;	)
		;)
	)
	(:constraints
		(:temporal
			(meets ?P1 ?THIS)
			(meets ?THIS ?E1)
		)
		(:prolog kb
			(isMobile ?Device)
			(adjacent ?L1 ?L2)
		)
	)
)

(:operator ;; face a device towards someone/something
	(face-device ?Device - device ?A - entity ?L - location)
	(:preconditions
		(?P1 (facing ?Device) none)
		(?P2 (at ?Device) ?L)
		(?P3 (at ?A) ?L)
	)
	(:effects
		(?E1 (facing ?Device) ?A)
	)
	(:constraints
		(:temporal
			(meets ?P1 ?THIS)
			(meets ?P1 ?E1)
			(equals ?E1 ?THIS)
			(during ?THIS ?P2 [1 inf] [1 inf])
			(during ?THIS ?P3 [1 inf] [1 inf])
		)
		(:prolog kb
			(canRotate ?Device)
		)
	)
)

(:operator ;; face a device towards an agent
	(stop-face-device ?Device - device ?A - entity ?L - location)
	(:preconditions
		(?P1 (facing ?Device) ?A)
		(?P2 (at ?Device) ?L)
		(?P3 (at ?A) ?L)
	)
	(:effects
		(?E1 (facing ?Device) none)
	)
	(:constraints
		(:temporal
			(meets ?P1 ?THIS)
			(meets ?P1 ?E1)
			(equals ?E1 ?THIS)
			(during ?THIS ?P2 [1 inf] [1 inf])
			(during ?THIS ?P3 [1 inf] [1 inf])
		)
		(:prolog kb
			(canRotate ?Device)
		)
	)
)

;;(:operator ;; split a goal interval into two temporal intervals
;;	(split-goal ?C)
;;	(:preconditions	)
;;	(:effects
;;		(?E (?inferring ?C))
;;	)
;;	(:constraints
;;		(:goal
;;			(?G1 (?inferring ?C))
;;			(?G2 (?inferring ?C))
;;		)
;;		(:temporal
;;			(starts ?G1 ?E [0 0] [0 inf])
;;			(finishes ?G2 ?E [0 0] [0 inf])	
;;			(overlaps ?G1 ?G2)
;;		)
;;	)
;;)



