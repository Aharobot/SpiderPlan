;; Created from:
;;
;; eating(John,t) :- fridgeDoor(_, Open, T1),
;; 									 fridgeDoor(_, Closed, T2),
;; 									 kitchenSeat(John, Pressed, t),
;; 									 T 1 < T 2 < t.
;;
;; add ASP
;; (with URLs)


;; Redundancy
;; -> Certainty of inference?
;; -> Aggregate concepts
;; Execution, connection to WP1 (how to wake up, set up comm., use processing nodes)
;; Create common domain
;; Also include stream reasoning
;; Contingencies

;; TODO: 
;; - Aggregate concepts 
;;   - Global concept (smoking) requires multiple local ones (smoking at location)
;;   - John smokes <=> disjunction over all l in L: John smokes at l
;; - Certainty
;;   - Combine multiple ways to infer concept to have higher likelyhood of correct inference
;;   - Would require encoding likelyhood in state-space somehow
;; - Why choose alternatives?
;;   - Sensors might be "forced off" (out of battery, maintainance, ...)
;;   - Communication temporarily impossible
;;   - Divide one goal into multiple intervals? 
;;     - Example: Use chair sensor first, then kitchen camera.
;;     - Possible solution: Decompose single goal in two (using operator or method?)
;;       - When to use this operator? (-> When nothing else works)
;;       - Could also help when fixing problems online
;; - Constraint type for network connectivity
;;   - Network may change over time
;;   - Can we have a fixed network with dynamic aspects? (e.g., removing edges for intervals?)
;; - Constraint type for ontology queries
;; - More operators with preconditions?
;; - Constraint type for ASP stream reasoning
;; - How to connect to WP1?
;; - What is executed?
;;   - Devices turned on and off
;;   - Robot moving
;;   - Sensors facing entities
;;   - Possobilities:
;;     - Inference tasks (machine m uses topic1..n to infer c)




(:initial-context
	(:domain
		;;;;;;;;;;;;;;;;;;;
		;; Inhabitants
		;;;;;;;;;;;;;;;;;;;
		(enum human { john })

		;;;;;;;;;;;;;;;;;;;
		;; Environment
		;;;;;;;;;;;;;;;;;;;
		(enum location { kitchen bedroom livingRoom bathroom })

		(enum bed { bedJohn })

		(enum chair {kitchenChair})
		
		(enum door {fridgeDoor})

		(enum tv {tvJohn})

		(enum shower {showerJohn})

		(enum stove {stoveJohn})

		(enum waterTap {bathroomTabJohn kitchenTabJohn})

		(enum objects 
			{
				bed
				chair
				stove
				tv 
				shower
				waterTap
				window
				door
			}
		)
		;;;;;;;;;;;;;;;;;;;
		;; Sensors
		;;;;;;;;;;;;;;;;;;;
		(enum sensorID 
			{ 
				;; Mobile sensors
				robot  

				;; Location-based sensors
				(pir location)
				
				(environmentalSensor location) ;; temperature, humidity
				(luminositySensor location)

				;; Object-based sensors
				(doorSensor door)
				(windowSensor window)
				(pressureSensor chair)
				(pressureSensor bed)

				(waterCurrentSensor shower)
				(waterCurrentSensor waterTap)

				(electricCurrentSensor tv)
				(electricCurrentSensor stove)

				;; Wearable sensors
			;;	(activityTracker human)

				;;(camera bedroom)
				;;(camera livingRoom)
				;;(camera kitchen)

				(camera location)
			}
		)
		(enum inferenceRequirement { none atLocation facingEntityAtLocation })
		(enum nodeID { node1 node2 robot })
		(enum nodeClass { lowPowerProcessor generalPurposeProcessor })
		;;;;;;;;;;;;;;;;;;;
		;; Concepts
		;;;;;;;;;;;;;;;;;;;
		(enum concept 
			{ 
				(activity human)
				(activityLevel human)  

				(eating human)
				(showering human)
				(sleeping human)
				(cooking human)

				(doorState door) 
				(windowState window) 
				(chairState chair) 
				(bedState bed) 

				(temperature location)
				(humidity location)
				(airQuality location)
				(luminosity location)

				(humanPressence location)

				(using waterTap)
				(using shower)
				(using tv)
				(using stove)
			}
		)
		(enum state {on off})
		;;;;;;;;;;;;;;;;;;;
		;; Devices
		;;;;;;;;;;;;;;;;;;;
		(enum device {sensorID nodeID})

		(enum agent {human device none})

		(enum entity { human robot sensorID bed chair stove tv shower waterTap window door none })
		
		(int ms [0 20000])
		(int energy [0 200000])
		(int costID [0 10000])

		(sig (at entity) location)
		(sig (facing device) entity)
		(sig (adjacent location location))

		(sig (facingEntityAtLocation entity))

		(sig (isMobile device))
		(sig (canRotate device))

		(sig (inferring concept))
		(sig (deviceEnergyConsumption device energy))
		(sig (device-state device) state)

		(sig (hasNodeClass nodeID nodeClass))

		(sig (capabilityBase nodeClass sensorID inferenceRequirement concept))
		(sig (capabilityTwo nodeClass concept concept concept))
		(sig (capabilityThree nodeClass concept concept concept concept))
	)
	(:statement
		(s1 (at john) kitchen)
		(s2 (at robot) kitchen)
		(s3 (facing robot) none)

		(s4 (at (camera bedroom)) bedroom)
		(s5 (at (camera livingRoom)) livingRoom)
		(s6 (at (camera kitchen)) kitchen)

		(s7 (at bedJohn) bedroom)
		(s8 (at kitchenChair) kitchen)
		(s9 (at fridgeDoor) kitchen)
		(s10 (at tvJohn) livingRoom)
		(s11 (at showerJohn) bathroom)
		(s12 (at stoveJohn) kitchen)
		(s13 (at bathroomTabJohn) bathroom)
		(s14 (at kitchenTabJohn) kitchen)
	)

	(:temporal
		(planning-interval [0 inf])
	)
	(:optimization
		(min energy)
	)

	(:include (kb "./kb.prolog"))

	(:ic
		(attach-costs ?Device ?I)
		(:condition
			(:statement
				(?I (device-state ?Device) on)
			)
			(:prolog kb 
				(deviceEnergyConsumption ?Device ?CostPerTimeUnit)
			)
		)
		(:resolver
			(:domain
				;; assure that each instance of this operator uses a unique cost ID
				(new-object ?CostID costID)
			)
			(:math 
				(eval-int (energyCostTotal ?CostID) (mult (sub (EET ?I) (LST ?I)) ?CostPerTimeUnit))
			)
			(:cost
				(add energy (energyCostTotal ?CostID))
			)
		)
	)
)

(:operator ;; infer concept from single sensor without any conditions
	(infer ?C - concept)
	(:preconditions )
	(:effects
		(?E1 (infer ?C))
		(?E2 (device-state ?Node) on)
		(?E3 (device-state ?SensorID) on)	
	)
	(:constraints
		(:temporal
			(equals ?THIS ?E1)
			(during ?THIS ?E2 [1 inf] [1 inf])
			(during ?THIS ?E3 [1 inf] [1 inf])
		)
		(:prolog kb
			(hasNodeClass ?Node ?NodeClass)
			(capabilityBase ?NodeClass ?SensorID none ?C)
		)
	)
)
;; Example: target concept (activity John)

(:operator ;; infer concept from single sensor with specific configuration
	(infer ?C - concept)
	(:preconditions 
		(?P1 (at ?H) ?L)
		(?P2 (at ?SensorID) ?L)
		(?P3 (facing ?SensorID) ?H)
	)
	(:effects
		(?E1 (infer ?C))
		(?E2 (device-state ?Node) on)
		(?E3 (device-state ?SensorID) on)	
	)
	(:constraints
		(:temporal
			(equals ?THIS ?E1)
			(during ?THIS ?E2 [1 inf] [1 inf])
			(during ?THIS ?E3 [1 inf] [1 inf])

			(during ?THIS ?P1 [1 inf] [1 inf])
			(during ?THIS ?P2 [1 inf] [1 inf])
			(during ?THIS ?P3 [1 inf] [1 inf])
		)
		(:prolog kb
			(location ?L)
			(hasNodeClass ?Node ?NodeClass)
			(capabilityBase ?NodeClass ?SensorID (facingEntityAtLocation ?H) ?C)
		)
	)
)

(:operator ;; infer a concept from two other concepts
	(infer ?C - concept)
	(:preconditions)
	(:effects
		(?E1 (infer ?C))
		(?E2 (device-state ?Node) on)
	)
	(:constraints
		(:task
			(?P1 (inferring ?Cbase))
		)
		(:temporal
			(equals ?THIS ?E1)
			(during ?THIS ?P1 [1 inf] [1 inf])
			(during ?THIS ?E2 [1 inf] [1 inf])
		)
		(:prolog kb
			(hasNodeClass ?Node ?NodeClass)
			(capabilityOne ?NodeClass ?Cbase ?C)
		)
	)
)

(:operator ;; infer a concept from two other concepts
	(infer ?C - concept)
	(:preconditions)
	(:effects
		(?E1 (infer ?C))
		(?E2 (device-state ?Node) on)
	)
	(:constraints
		(:task
			(?P1 (inferring ?Cbase1))
			(?P2 (inferring ?Cbase2))
		)
		(:temporal
			(equals ?THIS ?E1)
			(during ?THIS ?P1 [1 inf] [1 inf])
			(during ?THIS ?P2 [1 inf] [1 inf])
			(during ?THIS ?E2 [1 inf] [1 inf])
		)
		(:prolog kb
			(hasNodeClass ?Node ?NodeClass)
			(capabilityTwo ?NodeClass ?Cbase1 ?Cbase2 ?C)
		)
	)
)

(:operator ;; infer a concept from three other concepts
	(infer ?C - concept)
	(:preconditions)
	(:effects
		(?E1 (infer ?C))
		(?E2 (device-state ?Node) on)
	)
	(:constraints
		(:task
			(?P1 (inferring ?Cbase1))
			(?P2 (inferring ?Cbase2))
			(?P3 (inferring ?Cbase3))
		)
		(:temporal
			(equals ?THIS ?E1)
			(during ?THIS ?P1 [1 inf] [1 inf])
			(during ?THIS ?P2 [1 inf] [1 inf])
			(during ?THIS ?P3 [1 inf] [1 inf])
			(during ?THIS ?E2 [1 inf] [1 inf])
		)
		(:prolog kb
			(hasNodeClass ?Node ?NodeClass)
			;; node of specific class in current configuration can use the three base concepts to infer the target concept:
			(capabilityThree ?NodeClass ?Cbase1 ?Cbase2 ?Cbase3 ?C) 
		)
	)
)

(:operator 
	(move-device ?Device - device ?L1 - location ?L2 - location)
	(:preconditions
		(?P1 (at ?Device) ?L1)
	)
	(:effects
		(?E1 (at ?Device) ?L2)
	)
	(:constraints
		(:temporal
			(meets ?P1 ?THIS)
			(meets ?THIS ?E1)
		)
		(:prolog kb
			(isMobile ?Device)
			(adjacent ?L1 ?L2)
		)
	)
)

(:operator ;; face a device towards someone/something
	(face-device ?Device - device ?A - entity ?L - location)
	(:preconditions
		(?P1 (facing ?Device) none)
		(?P2 (at ?Device) ?L)
		(?P3 (at ?A) ?L)
	)
	(:effects
		(?E1 (facing ?Device) ?A)
	)
	(:constraints
		(:temporal
			(meets ?P1 ?THIS)
			(meets ?P1 ?E1)
			(equals ?E1 ?THIS)
			(during ?THIS ?P2 [1 inf] [1 inf])
			(during ?THIS ?P3 [1 inf] [1 inf])
		)
		(:prolog kb
			(canRotate ?Device)
		)
	)
)

(:operator ;; face a device towards an agent
	(stop-face-device ?Device - device ?A - entity ?L - location)
	(:preconditions
		(?P1 (facing ?Device) ?A)
		(?P2 (at ?Device) ?L)
		(?P3 (at ?A) ?L)
	)
	(:effects
		(?E1 (facing ?Device) none)
	)
	(:constraints
		(:temporal
			(meets ?P1 ?THIS)
			(meets ?P1 ?E1)
			(equals ?E1 ?THIS)
			(during ?THIS ?P2 [1 inf] [1 inf])
			(during ?THIS ?P3 [1 inf] [1 inf])
		)
		(:prolog kb
			(canRotate ?Device)
		)
	)
)

;;(:operator ;; split a goal interval into two temporal intervals
;;	(split-goal ?C)
;;	(:preconditions	)
;;	(:effects
;;		(?E (infer ?C))
;;	)
;;	(:constraints
;;		(:goal
;;			(?G1 (infer ?C))
;;			(?G2 (infer ?C))
;;		)
;;		(:temporal
;;			(starts ?G1 ?E [0 0] [0 inf])
;;			(finishes ?G2 ?E [0 0] [0 inf])	
;;			(overlaps ?G1 ?G2)
;;		)
;;	)
;;)



